* TODO refactoring + doc
- DONE separate lustre types from machine types in different files
- DONE split basic libs into backend specific files
- DONE define mli for core steps: normalization and machine code
- define mli for lustre_type and machine_type (Garion)

* TODO
** include files
** main function
*** add a clean test to forbid array arguments for main node
    (no available input/output methods)
** test suite
*** for complex dependency graphs (notably mem/mem cyclic dependencies)
*** for clocks
*** for arrays (non-generic nodes)
** compare with lus2c (verimag)
** extension
*** array access: done
*** add an option to dynamically check array accesses: done
*** power operator: done
*** automaton
*** annotations to ACSL
** init checking
*** to be done !!!
** normalization
*** sub-expression sharing seems to be not totally working: fixed
*** improve behavior for power and access operators:done
*** more type-directed normalization (notably to improve code gen for arrays): done
*** reuse of dead vars instead of systematically allocating new local vars
*** add a clean test for used but undefined nodes
** typing
*** correct typing of arith ops (real/int with subtyping ?)
*** display array dimensions with correct names: done
*** clocks must not be static inputs: done
** clock calculus
*** extension from named clocks to valued clocks ?
*** static inputs should be polymorphic, as global constants are: done

* Horn backend
** enum types for automaton
   - issues with MBranches and clocks
     - control-on-clock generates a "if cond then expr else nothing
     - it has to be expressed in a functional way to enable its expression as
       horn


-  The issue seems mainly to lie in the out = f(in) every cond
   this generates the follwoingg imperative statements
   if cond then f_reset(*mem) else {(nothing, ie. not reset)}
   f_step(in,*put,*mem)

   In the machine code, this is done by generating the sequence of 2 instructions
   1. if cond then MReset() else {}  (* creation of a conditional statement *)
   2. MStep()

- For Xavier: Syntactically, how could you "reset" an arrow? When we see an
  Expr_arrow, we introduce a MReset instance to the set of instruction on the
  reset function of the current node, but is there any mean to do it with
  "every" ?




x = expr when c

if c then
  x= expr

else {}

x = if c then expr else x
* Seal

The Seal library should be available from LustreV

lustrev -seal -node foo bar.lus 

shall inline completely the node foo in bar.lus and compile it as a
piecewise system: 
- Memories have to be identified and one needs to separate the update
  of the memories and the production of the output.
- The update block should be normalized so that any ite occuring in
  the definition of a memory should not define a local flow used in
  basic operations.  In other words, the definitions should look like
  mem_x = if g then e1 else e2 where e1 and e2 are either ite
  expression or expressions without ite. As soon as a not-ite
  expression is selected it cannot depend on the output of an ite.

In a first step this normalized update shall be printed in
stdout. Later it will associated to a SEAL datastructure through SEAL
API.

** Algorithm

*** 1. Computation of update block
- First we inline the node
- After normalization the memories are the variables defined by a pre
- Do we have to deal with arrows and reset?
- Develop a function to perform slicing. Restrict the node eqs to the ones used in these pre defs.
- one can also slice the expressions on the output variables

*** 2. Normalization: piecewise system
 ie. all ite pushed at the beginning

- use the scheduling to obtain the dependencies amongs eqs
- one can then iterate through eqs from the bottom to the top
  if the eq looks like x = if g then e1 else e2
  then tag x as ite(g,e1,e2)
  if the parent expr y = if g2 then x else ... make 
** More general use
Some ideas
- One could request multiple nodes: how to deal with these? Acting as
  as many calls to the basic procedure?
- Shall we keep the flatten update structure to the node? Another
  property on input could be propagated.
- The analysis will depend on bounds on input flows. Can we specialize
  the update blocks based on input values, ie. disabling some branches
  of the ite-tree?
- 

** TODO list

* Salsa
* 
