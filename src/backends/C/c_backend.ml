(* ----------------------------------------------------------------------------
 * SchedMCore - A MultiCore Scheduling Framework
 * Copyright (C) 2009-2013, ONERA, Toulouse, FRANCE - LIFL, Lille, FRANCE
 * Copyright (C) 2012-2013, INPT, Toulouse, FRANCE
 *
 * This file is part of Prelude
 *
 * Prelude is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation ; either version 2 of
 * the License, or (at your option) any later version.
 *
 * Prelude is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY ; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this program ; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
 * USA
 *---------------------------------------------------------------------------- *)

(* This module is used for the lustre to C compiler *)

open Format
open LustreSpec
open Corelang
open Machine_code
open C_backend_common


let print_machine_decl_prefix = ref (fun fmt x -> ())
(********************************************************************************************)
(*                     Basic      Printing functions                                        *)
(********************************************************************************************)

let print_version fmt =
  Format.fprintf fmt 
    "/* @[<v>C code generated by %s@,SVN version number %s@,Code is %s compliant */@,@]@."
    (Filename.basename Sys.executable_name) 
    Version.number 
    (if !Options.ansi then "ANSI C90" else "C99")


(********************************************************************************************)
(*                    Instruction Printing functions                                        *)
(********************************************************************************************)

(* Computes the depth to which multi-dimension array assignments should be expanded.
   It equals the maximum number of nested static array constructions accessible from root [v].
*)
let rec expansion_depth v =
 match v with
 | Cst (Const_array cl) -> 1 + List.fold_right (fun c -> max (expansion_depth (Cst c))) cl 0
 | Cst _
 | LocalVar _
 | StateVar _  -> 0
 | Fun (_, vl) -> List.fold_right (fun v -> max (expansion_depth v)) vl 0
 | Array vl    -> 1 + List.fold_right (fun v -> max (expansion_depth v)) vl 0
 | Access (v, i) -> max 0 (expansion_depth v - 1)
 | Power (v, n)  -> 0 (*1 + expansion_depth v*)

type loop_index = LVar of ident | LInt of int ref

(* Computes the list of nested loop variables together with their dimension bounds.
   - LInt r stands for loop expansion (no loop variable, but int loop index)
   - LVar v stands for loop variable v
*)
let rec mk_loop_variables m ty depth =
 match (Types.repr ty).Types.tdesc, depth with
 | Types.Tarray (d, ty'), 0       ->
   let v = mk_loop_var m () in
   (d, LVar v) :: mk_loop_variables m ty' 0
 | Types.Tarray (d, ty'), _       ->
   let r = ref (-1) in
   (d, LInt r) :: mk_loop_variables m ty' (depth - 1)
 | _                    , 0       -> []
 | _                              -> assert false

let reorder_loop_variables loop_vars =
  let (int_loops, var_loops) = 
    List.partition (function (d, LInt _) -> true | _ -> false) loop_vars 
  in
  var_loops @ int_loops
    
(* Prints a one loop variable suffix for arrays *)
let pp_loop_var fmt lv =
 match snd lv with
 | LVar v -> fprintf fmt "[%s]" v
 | LInt r -> fprintf fmt "[%d]" !r

(* Prints a suffix of loop variables for arrays *)
let pp_suffix fmt loop_vars =
 Utils.fprintf_list ~sep:"" pp_loop_var fmt loop_vars

(* Prints a [value] indexed by the suffix list [loop_vars] *)
let rec pp_value_suffix self loop_vars pp_value fmt value =
 match loop_vars, value with
 | (_, LInt r) :: q, Array vl     ->
   pp_value_suffix self q pp_value fmt (List.nth vl !r)
 | _           :: q, Power (v, n) ->
   pp_value_suffix self loop_vars pp_value fmt v
 | _               , Fun (n, vl)  ->
   Basic_library.pp_c n (pp_value_suffix self loop_vars pp_value) fmt vl
 | _               , _            ->
   let pp_var_suffix fmt v = fprintf fmt "%a%a" pp_value v pp_suffix loop_vars in
   pp_c_val self pp_var_suffix fmt value

(* type_directed assignment: array vs. statically sized type
   - [var_type]: type of variable to be assigned
   - [var_name]: name of variable to be assigned
   - [value]: assigned value
   - [pp_var]: printer for variables
*)
let pp_assign m self pp_var fmt var_type var_name value =
  let depth = expansion_depth value in
(*eprintf "pp_assign %a %a %d@." Types.print_ty var_type pp_val value depth;*)
  let loop_vars = mk_loop_variables m var_type depth in
  let reordered_loop_vars = reorder_loop_variables loop_vars in
  let rec aux fmt vars =
    match vars with
    | [] ->
      fprintf fmt "%a = %a;" 
	(pp_value_suffix self loop_vars pp_var) var_name
	(pp_value_suffix self loop_vars pp_var) value
    | (d, LVar i) :: q ->
(*eprintf "pp_aux %a %s@." Dimension.pp_dimension d i;*)
      fprintf fmt "@[<v 2>{@,int %s;@,for(%s=0;%s<%a;%s++)@,%a @]@,}"
	i i i Dimension.pp_dimension d i
	aux q
    | (d, LInt r) :: q ->
(*eprintf "pp_aux %a %d@." Dimension.pp_dimension d (!r);*)
      let szl = Utils.enumerate (Dimension.size_const_dimension d) in
      fprintf fmt "@[<v 2>{@,%a@]@,}"
	(Utils.fprintf_list ~sep:"@," (fun fmt i -> r := i; aux fmt q)) szl
  in
  begin
    reset_loop_counter ();
    (*reset_addr_counter ();*)
    aux fmt reordered_loop_vars
  end

let pp_instance_call m self fmt i (inputs: value_t list) (outputs: var_decl list) =
 try (* stateful node instance *)
   let (n,_) = List.assoc i m.minstances in
   fprintf fmt "%a (%a%t%a%t%s->%s);"
     pp_machine_step_name (node_name n)
     (Utils.fprintf_list ~sep:", " (pp_c_val self (pp_c_var_read m))) inputs
     (Utils.pp_final_char_if_non_empty ", " inputs) 
     (Utils.fprintf_list ~sep:", " (pp_c_var_write m)) outputs
     (Utils.pp_final_char_if_non_empty ", " outputs)
     self
     i
 with Not_found -> (* stateless node instance *)
   let (n,_) = List.assoc i m.mcalls in
   fprintf fmt "%a (%a%t%a);"
     pp_machine_step_name (node_name n)
     (Utils.fprintf_list ~sep:", " (pp_c_val self (pp_c_var_read m))) inputs
     (Utils.pp_final_char_if_non_empty ", " inputs) 
     (Utils.fprintf_list ~sep:", " (pp_c_var_write m)) outputs 

let pp_machine_reset (m: machine_t) self fmt inst =
  let (node, static) = List.assoc inst m.minstances in
  fprintf fmt "%a(%a%t%s->%s);"
    pp_machine_reset_name (node_name node)
    (Utils.fprintf_list ~sep:", " Dimension.pp_dimension) static
    (Utils.pp_final_char_if_non_empty ", " static)
    self inst

let has_c_prototype funname dependencies =
  let imported_node_opt = (* We select the last imported node with the name funname.
			       The order of evaluation of dependencies should be
			       compatible with overloading. (Not checked yet) *) 
      List.fold_left
	(fun res (_, _, decls) -> 
	  match res with
	  | Some _ -> res
	  | None -> 
	    let matched = fun t -> match t.top_decl_desc with 
	      | ImportedNode nd -> nd.nodei_id = funname 
	      | _ -> false
	    in
	    if List.exists matched decls then (
	      match (List.find matched decls).top_decl_desc with
	      | ImportedNode nd -> Some nd
	      | _ -> assert false
	    )
	    else
	      None
	) None dependencies in
    match imported_node_opt with
    | None -> false
    | Some nd -> (match nd.nodei_prototype with Some "C" -> true | _ -> false)

let rec pp_conditional dependencies (m: machine_t) self fmt c tl el =
  fprintf fmt "@[<v 2>if (%a) {%t%a@]@,@[<v 2>} else {%t%a@]@,}"
    (pp_c_val self (pp_c_var_read m)) c
    (Utils.pp_newline_if_non_empty tl)
    (Utils.fprintf_list ~sep:"@," (pp_machine_instr dependencies m self)) tl
    (Utils.pp_newline_if_non_empty el)
    (Utils.fprintf_list ~sep:"@," (pp_machine_instr dependencies m self)) el

and pp_machine_instr dependencies (m: machine_t) self fmt instr =
  match instr with 
  | MReset i ->
    pp_machine_reset m self fmt i
  | MLocalAssign (i,v) ->
    pp_assign
      m self (pp_c_var_read m) fmt
      i.var_type (LocalVar i) v
  | MStateAssign (i,v) ->
    pp_assign
      m self (pp_c_var_read m) fmt
      i.var_type (StateVar i) v
  | MStep ([i0], i, vl) when Basic_library.is_internal_fun i  ->
    pp_machine_instr dependencies m self fmt (MLocalAssign (i0, Fun (i, vl)))
  | MStep ([i0], i, vl) when has_c_prototype i dependencies -> 
    fprintf fmt "%a = %s(%a);" 
      (pp_c_val self (pp_c_var_read m)) (LocalVar i0) 
      i
      (Utils.fprintf_list ~sep:", " (pp_c_val self (pp_c_var_read m))) vl
  | MStep (il, i, vl) ->
    pp_instance_call m self fmt i vl il
  | MBranch (g,hl) ->
    if hl <> [] && let t = fst (List.hd hl) in t = tag_true || t = tag_false
    then (* boolean case, needs special treatment in C because truth value is not unique *)
	 (* may disappear if we optimize code by replacing last branch test with default *)
      let tl = try List.assoc tag_true  hl with Not_found -> [] in
      let el = try List.assoc tag_false hl with Not_found -> [] in
      pp_conditional dependencies m self fmt g tl el
    else (* enum type case *)
      fprintf fmt "@[<v 2>switch(%a) {@,%a@,}@]"
	(pp_c_val self (pp_c_var_read m)) g
	(Utils.fprintf_list ~sep:"@," (pp_machine_branch dependencies m self)) hl

and pp_machine_branch dependencies m self fmt (t, h) =
  fprintf fmt "@[<v 2>case %a:@,%a@,break;@]" pp_c_tag t (Utils.fprintf_list ~sep:"@," (pp_machine_instr dependencies m self)) h



(********************************************************************************************)
(*                      Prototype Printing functions                                        *)
(********************************************************************************************)

let print_alloc_prototype fmt (name, static) =
  fprintf fmt "%a * %a (%a)"
    pp_machine_memtype_name name
    pp_machine_alloc_name name
    (Utils.fprintf_list ~sep:",@ " pp_c_decl_input_var) static

let print_reset_prototype self fmt (name, static) =
  fprintf fmt "void %a (@[<v>%a%t%a *%s@])"
    pp_machine_reset_name name
    (Utils.fprintf_list ~sep:",@ " pp_c_decl_input_var) static
    (Utils.pp_final_char_if_non_empty ",@," static) 
    pp_machine_memtype_name name
    self

let print_stateless_prototype fmt (name, inputs, outputs) =
  fprintf fmt "void %a (@[<v>@[%a%t@]@,@[%a@]@,@])"
    pp_machine_step_name name
    (Utils.fprintf_list ~sep:",@ " pp_c_decl_input_var) inputs
    (Utils.pp_final_char_if_non_empty ",@ " inputs) 
    (Utils.fprintf_list ~sep:",@ " pp_c_decl_output_var) outputs

let print_step_prototype self fmt (name, inputs, outputs) =
  fprintf fmt "void %a (@[<v>@[%a%t@]@,@[%a@]%t@[%a *%s@]@])"
    pp_machine_step_name name
    (Utils.fprintf_list ~sep:",@ " pp_c_decl_input_var) inputs
    (Utils.pp_final_char_if_non_empty ",@ " inputs) 
    (Utils.fprintf_list ~sep:",@ " pp_c_decl_output_var) outputs
    (Utils.pp_final_char_if_non_empty ",@," outputs) 
    pp_machine_memtype_name name
    self

(********************************************************************************************)
(*                         Header Printing functions                                        *)
(********************************************************************************************)


let print_import_standard fmt =
  fprintf fmt "#include \"%s/include/lustrec/arrow.h\"@.@." Version.prefix

let print_import_prototype fmt (s, _, _) =
  fprintf fmt "#include \"%s.h\"@," s
    
let pp_registers_struct fmt m =
  if m.mmemory <> []
  then
    fprintf fmt "@[%a {@[%a; @]}@] _reg; "
      pp_machine_regtype_name m.mname.node_id
      (Utils.fprintf_list ~sep:"; " pp_c_decl_struct_var) m.mmemory
  else
    ()

let print_machine_struct fmt m =
  if fst (get_stateless_status m) then
    begin
    end
  else
    begin
      (* Define struct *)
      fprintf fmt "@[%a {@[%a%a%t@]};@]@."
	pp_machine_memtype_name m.mname.node_id
	pp_registers_struct m
	(Utils.fprintf_list ~sep:"; " pp_c_decl_instance_var) m.minstances
	(Utils.pp_final_char_if_non_empty "; " m.minstances)
    end

let print_static_declare_instance attr fmt (i, (m, static)) =
  fprintf fmt "%a(%s, %a%t%s)"
    pp_machine_static_declare_name (node_name m)
    attr
    (Utils.fprintf_list ~sep:", " Dimension.pp_dimension) static
    (Utils.pp_final_char_if_non_empty ", " static)
    i

let print_static_declare_macro fmt m =
  let array_mem = List.filter (fun v -> Types.is_array_type v.var_type) m.mmemory in
  let inst = mk_instance m in
  let attr = mk_attribute m in
  fprintf fmt "@[<v 2>#define %a(%s, %a%t%s)\\@,%s %a %s;\\@,%a%t%a;@,@]"
    pp_machine_static_declare_name m.mname.node_id
    attr
    (Utils.fprintf_list ~sep:", " (pp_c_var_read m)) m.mstatic
    (Utils.pp_final_char_if_non_empty ", " m.mstatic)
    inst
    attr
    pp_machine_memtype_name m.mname.node_id
    inst
    (Utils.fprintf_list ~sep:";\\@," pp_c_decl_local_var) array_mem
    (Utils.pp_final_char_if_non_empty ";\\@," array_mem)
    (Utils.fprintf_list ~sep:";\\@,"
       (fun fmt (i',m') ->
	 let path = sprintf "inst ## _%s" i' in
	 fprintf fmt "%a"
	   (print_static_declare_instance attr) (path,m')
       )) m.minstances

      
let print_static_link_instance fmt (i, (m, _)) =
 fprintf fmt "%a(%s)" pp_machine_static_link_name (node_name m) i

(* Allocation of a node struct:
   - if node memory is an array/matrix/etc, we cast it to a pointer (see pp_registers_struct)
*)
let print_static_link_macro fmt m =
  let array_mem = List.filter (fun v -> Types.is_array_type v.var_type) m.mmemory in
  fprintf fmt "@[<v>@[<v 2>#define %a(inst) do {\\@,%a%t%a;\\@]@,} while (0)@.@]"
    pp_machine_static_link_name m.mname.node_id
    (Utils.fprintf_list ~sep:";\\@,"
       (fun fmt v ->
	 fprintf fmt "inst._reg.%s = (%a*) &%s"
	   v.var_id
           (fun fmt v -> pp_c_type "" fmt (Types.array_base_type v.var_type)) v
	   v.var_id
       )) array_mem
    (Utils.pp_final_char_if_non_empty ";\\@," array_mem)
    (Utils.fprintf_list ~sep:";\\@,"
       (fun fmt (i',m') ->
	 let path = sprintf "inst ## _%s" i' in
	 fprintf fmt "%a;\\@,inst.%s = &%s"
	   print_static_link_instance (path,m')
	   i'
	   path
       )) m.minstances
      
let print_static_alloc_macro fmt m =
  fprintf fmt "@[<v>@[<v 2>#define %a(attr,%a%tinst)\\@,%a(attr,%a%tinst);\\@,%a(inst);@]@,@]@."
    pp_machine_static_alloc_name m.mname.node_id
    (Utils.fprintf_list ~sep:", " (pp_c_var_read m)) m.mstatic
    (Utils.pp_final_char_if_non_empty ", " m.mstatic)
    pp_machine_static_declare_name m.mname.node_id
    (Utils.fprintf_list ~sep:", " (pp_c_var_read m)) m.mstatic
    (Utils.pp_final_char_if_non_empty ", " m.mstatic)
    pp_machine_static_link_name m.mname.node_id

 
let print_machine_decl fmt m =
  !print_machine_decl_prefix fmt m;
  if fst (get_stateless_status m) then
    begin
      fprintf fmt "extern %a;@.@."
	print_stateless_prototype
	(m.mname.node_id, m.mstep.step_inputs, m.mstep.step_outputs)
    end
  else
    begin
      (* Static allocation *)
      if !Options.static_mem
      then (
	fprintf fmt "%a@.%a@.%a@."
	  print_static_declare_macro m
	  print_static_link_macro m
	  print_static_alloc_macro m
      )
      else ( 
        (* Dynamic allocation *)
	fprintf fmt "extern %a;@.@."
	  print_alloc_prototype (m.mname.node_id, m.mstatic)
      );
      let self = mk_self m in
      fprintf fmt "extern %a;@.@."
	(print_reset_prototype self) (m.mname.node_id, m.mstatic);

      fprintf fmt "extern %a;@.@."
	(print_step_prototype self)
	(m.mname.node_id, m.mstep.step_inputs, m.mstep.step_outputs)
    end


(********************************************************************************************)
(*                         C file Printing functions                                        *)
(********************************************************************************************)

let print_const_def fmt cdecl =
  fprintf fmt "%a = %a;@." 
    (pp_c_type cdecl.const_id) cdecl.const_type
    pp_c_const cdecl.const_value 

let print_const_decl fmt cdecl =
  fprintf fmt "extern %a;@." 
    (pp_c_type cdecl.const_id) cdecl.const_type

let print_alloc_instance fmt (i, (m, static)) =
  fprintf fmt "_alloc->%s = %a (%a);@,"
    i
    pp_machine_alloc_name (node_name m)
    (Utils.fprintf_list ~sep:", " Dimension.pp_dimension) static

let print_alloc_array fmt vdecl =
  let base_type = Types.array_base_type vdecl.var_type in
  let size_types = Types.array_type_multi_dimension vdecl.var_type in
  let size_type = Dimension.multi_dimension_product vdecl.var_loc size_types in
  fprintf fmt "_alloc->_reg.%s = (%a*) malloc((%a)*sizeof(%a));@,assert(_alloc->%s);@,"
    vdecl.var_id
    (pp_c_type "") base_type
    Dimension.pp_dimension size_type
    (pp_c_type "") base_type
    vdecl.var_id

let print_alloc_code fmt m =
  let array_mem = List.filter (fun v -> Types.is_array_type v.var_type) m.mmemory in
  fprintf fmt "%a *_alloc;@,_alloc = (%a *) malloc(sizeof(%a));@,assert(_alloc);@,%a%areturn _alloc;"
    pp_machine_memtype_name m.mname.node_id
    pp_machine_memtype_name m.mname.node_id
    pp_machine_memtype_name m.mname.node_id
    (Utils.fprintf_list ~sep:"" print_alloc_array) array_mem
    (Utils.fprintf_list ~sep:"" print_alloc_instance) m.minstances

let print_stateless_code dependencies fmt m =
  let self = "__ERROR__" in
  if not (!Options.ansi && is_generic_node { top_decl_desc = Node m.mname; top_decl_loc = Location.dummy_loc })
  then
    (* C99 code *)
    fprintf fmt "@[<v 2>%a {@,%a%t@,%a%a%t%t@]@,}@.@."
      print_stateless_prototype (m.mname.node_id, m.mstep.step_inputs, m.mstep.step_outputs)
      (* locals *)
      (Utils.fprintf_list ~sep:";@," pp_c_decl_local_var) m.mstep.step_locals
      (Utils.pp_final_char_if_non_empty ";@," m.mstep.step_locals)
      (* check assertions *)
      (pp_c_checks self) m
      (* instrs *)
      (Utils.fprintf_list ~sep:"@," (pp_machine_instr dependencies m self)) m.mstep.step_instrs
      (Utils.pp_newline_if_non_empty m.mstep.step_instrs)
      (fun fmt -> fprintf fmt "return;")
  else
    (* C90 code *)
    let (gen_locals, base_locals) = List.partition (fun v -> Types.is_generic_type v.var_type) m.mstep.step_locals in
    let gen_calls = List.map (fun e -> let (id, _, _) = call_of_expr e in mk_call_var_decl e.expr_loc id) m.mname.node_gencalls in
    fprintf fmt "@[<v 2>%a {@,%a%t@,%a%a%t%t@]@,}@.@."
      print_stateless_prototype (m.mname.node_id, (m.mstep.step_inputs@gen_locals@gen_calls), m.mstep.step_outputs)
      (* locals *)
      (Utils.fprintf_list ~sep:";@," pp_c_decl_local_var) base_locals
      (Utils.pp_final_char_if_non_empty ";" base_locals)
      (* check assertions *)
      (pp_c_checks self) m
      (* instrs *)
      (Utils.fprintf_list ~sep:"@," (pp_machine_instr dependencies m self)) m.mstep.step_instrs
      (Utils.pp_newline_if_non_empty m.mstep.step_instrs)
      (fun fmt -> fprintf fmt "return;")

let print_reset_code dependencies fmt m self =
  fprintf fmt "@[<v 2>%a {@,%a%treturn;@]@,}@.@."
    (print_reset_prototype self) (m.mname.node_id, m.mstatic)
    (Utils.fprintf_list ~sep:"@," (pp_machine_instr dependencies m self)) m.minit
    (Utils.pp_newline_if_non_empty m.minit)

let print_step_code dependencies fmt m self =
  if not (!Options.ansi && is_generic_node { top_decl_desc = Node m.mname; top_decl_loc = Location.dummy_loc })
  then
    (* C99 code *)
    let array_mems = List.filter (fun v -> Types.is_array_type v.var_type) m.mmemory in
    fprintf fmt "@[<v 2>%a {@,%a%t%a%t@,%a%a%t%t@]@,}@.@."
      (print_step_prototype self) (m.mname.node_id, m.mstep.step_inputs, m.mstep.step_outputs)
      (* locals *)
      (Utils.fprintf_list ~sep:";@," pp_c_decl_local_var) m.mstep.step_locals
      (Utils.pp_final_char_if_non_empty ";@," m.mstep.step_locals)
      (* array mems *)
      (Utils.fprintf_list ~sep:";@," (pp_c_decl_array_mem self)) array_mems
      (Utils.pp_final_char_if_non_empty ";@," array_mems)
      (* check assertions *)
      (pp_c_checks self) m
      (* instrs *)
      (Utils.fprintf_list ~sep:"@," (pp_machine_instr dependencies m self)) m.mstep.step_instrs
      (Utils.pp_newline_if_non_empty m.mstep.step_instrs)
      (fun fmt -> fprintf fmt "return;")
  else
    (* C90 code *)
    let (gen_locals, base_locals) = List.partition (fun v -> Types.is_generic_type v.var_type) m.mstep.step_locals in
    let gen_calls = List.map (fun e -> let (id, _, _) = call_of_expr e in mk_call_var_decl e.expr_loc id) m.mname.node_gencalls in
    fprintf fmt "@[<v 2>%a {@,%a%t@,%a%a%t%t@]@,}@.@."
      (print_step_prototype self) (m.mname.node_id, (m.mstep.step_inputs@gen_locals@gen_calls), m.mstep.step_outputs)
      (* locals *)
      (Utils.fprintf_list ~sep:";@," pp_c_decl_local_var) base_locals
      (Utils.pp_final_char_if_non_empty ";" base_locals)
      (* check assertions *)
      (pp_c_checks self) m
      (* instrs *)
      (Utils.fprintf_list ~sep:"@," (pp_machine_instr dependencies m self)) m.mstep.step_instrs
      (Utils.pp_newline_if_non_empty m.mstep.step_instrs)
      (fun fmt -> fprintf fmt "return;")

let print_machine dependencies fmt m =
  if fst (get_stateless_status m) then
    begin
      (* Step function *)
      print_stateless_code dependencies fmt m
    end
  else
    begin
      (* Alloc function, only if non static mode *)
      if (not !Options.static_mem) then  
	(
	  fprintf fmt "@[<v 2>%a {@,%a@]@,}@.@."
	    print_alloc_prototype (m.mname.node_id, m.mstatic)
	    print_alloc_code m;
	);
      let self = mk_self m in
      (* Reset function *)
      print_reset_code dependencies fmt m self;
      (* Step function *)
      print_step_code dependencies fmt m self
    end



let header_has_code header =
  List.exists 
    (fun top -> 
      match top.top_decl_desc with
      | Consts _ -> true 
      | ImportedNode nd -> nd.nodei_in_lib = None
      | _ -> false
    )
    header

let header_libs header =
  List.fold_left (fun accu top ->
    match top.top_decl_desc with
      | ImportedNode nd -> (match nd.nodei_in_lib with 
	| None -> accu 
	| Some lib -> Utils.list_union [lib] accu)
      | _ -> accu 
  ) [] header 
    
let print_makefile basename nodename dependencies fmt =
  let compiled_dependencies = 
    List.filter (fun (_, _, header) -> header_has_code header) dependencies
  in
  let lib_dependencies = 
    List.fold_left 
      (fun accu (_, _, header) -> Utils.list_union (header_libs header) accu) [] dependencies 
  in
  fprintf fmt "GCC=gcc@.";
  fprintf fmt "LUSTREC=%s@." Sys.executable_name;
  fprintf fmt "LUSTREC_BASE=%s@." (Filename.dirname (Filename.dirname Sys.executable_name));
  fprintf fmt "INC=${LUSTREC_BASE}/include/lustrec@.";
  fprintf fmt "@.";
  fprintf fmt "%s_%s:@." basename nodename;
  fprintf fmt "\t${GCC} -I${INC} -I. -c %s.c@." basename;    
  List.iter (fun s -> (* Format.eprintf "Adding dependency: %s@." s;  *)
    fprintf fmt "\t${GCC} -I${INC} -c %s@." s)
    (("${INC}/io_frontend.c"):: (* IO functions when a main function is computed *)
	(List.map 
	   (fun (s, local, _) -> 
	     (if local then s else Version.prefix ^ "/include/lustrec/" ^ s) ^ ".c")
	   compiled_dependencies));    
  fprintf fmt "\t${GCC} -o %s_%s io_frontend.o %a %s.o %a@." basename nodename 
    (Utils.fprintf_list ~sep:" " (fun fmt (s, _, _) -> Format.fprintf fmt "%s.o" s)) compiled_dependencies 
    basename
    (Utils.fprintf_list ~sep:" " (fun fmt lib -> fprintf fmt "-l%s" lib)) lib_dependencies
    ;
 fprintf fmt "@.";
 fprintf fmt "clean:@.";
 fprintf fmt "\t\\rm -f *.o %s_%s@." basename nodename


let rec pp_c_struct_type_field filename cpt fmt (label, tdesc) =
  fprintf fmt "%a;" (pp_c_type_decl filename cpt label) tdesc
and pp_c_type_decl filename cpt var fmt tdecl =
  match tdecl with
  | Tydec_any           -> assert false
  | Tydec_int           -> fprintf fmt "int %s" var
  | Tydec_real          -> fprintf fmt "double %s" var
  | Tydec_float         -> fprintf fmt "float %s" var
  | Tydec_bool          -> fprintf fmt "_Bool %s" var
  | Tydec_clock ty      -> pp_c_type_decl filename cpt var fmt ty
  | Tydec_const c       -> fprintf fmt "%s %s" c var
  | Tydec_array (d, ty) -> fprintf fmt "%a[%a]" (pp_c_type_decl filename cpt var) ty pp_c_dimension d
  | Tydec_enum tl ->
    begin
      incr cpt;
      fprintf fmt "enum _enum_%s_%d { %a } %s" filename !cpt (Utils.fprintf_list ~sep:", " pp_print_string) tl var
    end
  | Tydec_struct fl ->
    begin
      incr cpt;
      fprintf fmt "struct _struct_%s_%d { %a } %s" filename !cpt (Utils.fprintf_list ~sep:" " (pp_c_struct_type_field filename cpt)) fl var
    end

let print_type_definitions fmt filename =
  let cpt_type = ref 0 in
  Hashtbl.iter (fun typ def ->
    match typ with
    | Tydec_const var ->
      fprintf fmt "typedef %a;@.@."
	(pp_c_type_decl filename cpt_type var) def
    | _        -> ()) type_table



(********************************************************************************************)
(*                         Translation function                                             *)
(********************************************************************************************)
let print_header header_fmt basename prog machines =
  (* Include once: start *)
  let baseNAME = String.uppercase basename in
  let baseNAME = Str.global_replace (Str.regexp "\\.\\|\\ ") "_" baseNAME in
  (* Print the svn version number and the supported C standard (C90 or C99) *)
  print_version header_fmt;
  fprintf header_fmt "#ifndef _%s@.#define _%s@." baseNAME baseNAME;
  pp_print_newline header_fmt ();
  fprintf header_fmt "/* Imports standard library */@.";
  (* imports standard library definitions (arrow) *)
  print_import_standard header_fmt;
  pp_print_newline header_fmt ();
  fprintf header_fmt "/* Types definitions */@.";
  (* Print the type definitions from the type table *)
  print_type_definitions header_fmt basename;
  pp_print_newline header_fmt ();
  (* Print the global constant declarations. *)
  fprintf header_fmt "/* Global constant (declarations, definitions are in C file) */@.";
  List.iter (fun c -> print_const_decl header_fmt c) (get_consts prog);
  pp_print_newline header_fmt ();
  (* Print the struct declarations of all machines. *)
  fprintf header_fmt "/* Struct declarations */@.";
  List.iter (print_machine_struct header_fmt) machines;
  pp_print_newline header_fmt ();
  (* Print the prototypes of all machines *)
  fprintf header_fmt "/* Nodes declarations */@.";
  List.iter (print_machine_decl header_fmt) machines;
  pp_print_newline header_fmt ();
  (* Include once: end *)
  fprintf header_fmt "#endif@.";
  pp_print_newline header_fmt ()

let print_c source_fmt basename prog machines dependencies =

  (* If a main node is identified, generate a main function for it *)
  let main_include, main_print, main_makefile =
    match !Options.main_node with
      | "" -> (fun _ -> ()), (fun _ -> ()), (fun _ -> ())
      | main_node -> (
	match Machine_code.get_machine_opt main_node machines with
	| None -> eprintf "Unable to find a main node named %s@.@?" main_node; (fun _ -> ()), (fun _ -> ()), (fun _ -> ())
	| Some m -> C_backend_main.print_main_header, C_backend_main.print_main_fun machines m, print_makefile basename !Options.main_node dependencies
      )
  in
  main_include source_fmt;
  fprintf source_fmt "#include <stdlib.h>@.#include <assert.h>@.#include \"%s\"@.@." (basename^".h");
  (* Print the svn version number and the supported C standard (C90 or C99) *)
  print_version source_fmt;
  (* Print the prototype of imported nodes *)
  fprintf source_fmt "/* Imported nodes declarations */@.";
  fprintf source_fmt "@[<v>";
  List.iter (print_import_prototype source_fmt) dependencies;
  fprintf source_fmt "@]@.";
  (* Print consts *)
  fprintf source_fmt "/* Global constants (definitions) */@.";
  List.iter (fun c -> print_const_def source_fmt c) (get_consts prog);
  pp_print_newline source_fmt ();
  (* Print nodes one by one (in the previous order) *)
  List.iter (print_machine dependencies source_fmt) machines;
  main_print source_fmt

let translate_to_c header_fmt source_fmt makefile_fmt spec_fmt_opt 
                   basename prog machines dependencies =

  (* Generating H file *)
  print_header header_fmt basename prog machines;

  (* Generating C file *)
  print_c source_fmt basename prog machines dependencies;

  (* Generating Makefile *)
  (* If a main node is identified, generate a main target for it *)
  match !Options.main_node with
      | "" ->  ()
      | main_node -> (
	match Machine_code.get_machine_opt main_node machines with
	| None -> eprintf "Unable to find a main node named %s@.@?" main_node; 
	  ()
	| Some m -> print_makefile basename !Options.main_node dependencies makefile_fmt
      )

(* Local Variables: *)
(* compile-command:"make -C .." *)
(* End: *)
